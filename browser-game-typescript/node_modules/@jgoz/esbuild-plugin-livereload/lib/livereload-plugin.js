"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.notify = exports.clientMessageBuilder = exports.livereloadPlugin = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const server_1 = require("./server");
const clients = new Set();
const errorSources = new Map();
/**
 * An esbuild plugin that sets up a livereload server and modifies the
 * build options to enable reload-on-change behavior and error reporting.
 *
 * @param options - Options for the livereload plugin.
 * @returns - An esbuild plugin that enables livereload.
 */
function livereloadPlugin(options = {}) {
    const { port = 53099, host = '127.0.0.1', urlHostname = host } = options;
    const baseUrl = `http://${urlHostname}:${port}/`;
    return {
        name: 'livereload-plugin',
        async setup(build) {
            const { absWorkingDir: basedir = process.cwd() } = build.initialOptions;
            const bannerTemplate = await fs_1.promises.readFile(require.resolve('../banner.js'), 'utf-8');
            const banner = bannerTemplate.replace(/{baseUrl}/g, baseUrl);
            await (0, server_1.createLivereloadServer)({
                basedir,
                host,
                port,
                urlHostname,
                onSSE: res => clients.add(res),
            });
            build.initialOptions.banner ??= {};
            if (build.initialOptions.banner.js) {
                build.initialOptions.banner.js += `;${banner}`;
            }
            else {
                build.initialOptions.banner.js = banner;
            }
            let fullReloadOnCssUpdates = options.fullReloadOnCssUpdates;
            if (!build.initialOptions.metafile) {
                console.warn('[esbuild-plugin-livereload]: "metafile" option is disabled, so all changes will trigger a full reload');
                fullReloadOnCssUpdates = true;
            }
            if (!build.initialOptions.write && !options.fullReloadOnCssUpdates) {
                console.warn('[esbuild-plugin-livereload]: "write" option is disabled, so CSS updates will trigger a full reload');
                fullReloadOnCssUpdates = true;
            }
            const messageBuilder = clientMessageBuilder(build.initialOptions, fullReloadOnCssUpdates);
            build.onEnd(async (result) => {
                const message = await messageBuilder(result);
                notify('esbuild', message);
            });
        },
    };
}
exports.livereloadPlugin = livereloadPlugin;
/**
 * Creates a stateful function that generates messages for connected clients.
 *
 * Build outputs are tracked between builds and differentials are calculated
 * with each subsequent build.
 *
 * @param options - esbuild build options
 * @param fullReloadOnCssUpdates - If true, CSS updates will always trigger a full page reload
 * @returns - A function that generates messages for connected clients
 */
function clientMessageBuilder(options, fullReloadOnCssUpdates = false) {
    const outputHashes = new Map();
    const { absWorkingDir: basedir = process.cwd(), outdir } = options;
    const absOutDir = outdir ? path_1.default.resolve(basedir, outdir) : undefined;
    function publicPath(file) {
        if (absOutDir) {
            const relative = path_1.default.relative(absOutDir, file);
            return relative.startsWith('/') ? relative : `/${relative}`;
        }
        return file;
    }
    return async function buildMessage(result) {
        const added = [];
        const removed = [];
        const updated = [];
        const nextHashes = [];
        if (result.metafile) {
            const absOutputs = Object.keys(result.metafile.outputs)
                .filter(o => !o.endsWith('.map'))
                .map(o => path_1.default.resolve(basedir, o));
            for (const outputFile of absOutputs) {
                const prevHash = outputHashes.get(outputFile);
                const hash = await calculateHash(outputFile);
                if (prevHash) {
                    outputHashes.delete(outputFile);
                    if (prevHash !== hash) {
                        updated.push(publicPath(outputFile));
                    }
                }
                else {
                    added.push(publicPath(outputFile));
                }
                nextHashes.push([outputFile, hash]);
            }
            for (const outputFile of outputHashes.keys()) {
                removed.push(publicPath(outputFile));
            }
            outputHashes.clear();
            for (const [outputFile, hash] of nextHashes) {
                outputHashes.set(outputFile, hash);
            }
        }
        return {
            added,
            removed,
            updated,
            warnings: result.warnings,
            errors: result.errors,
            forceReload: fullReloadOnCssUpdates,
        };
    };
}
exports.clientMessageBuilder = clientMessageBuilder;
/**
 * Notifies connected clients that errors or warnings occurred from
 * a given source. If there are no errors and the notification originates
 * from esbuild, the page will be sent a reload request.
 *
 * @param errorSource - Key to use when identifying these errors and warnings.
 *                      Previous results will be overwritten for the same `errorSource`.
 * @param msg - Object containing errors and warnings from the given source
 * @param connectedClients - Set of long-lived server responses representing
 *                           clients currently connected to the livereload
 *                           server. Only required if you are implementing your
 *                           own livereload server.
 */
function notify(errorSource, msg, connectedClients = clients) {
    errorSources.set(errorSource, msg);
    const values = Array.from(errorSources.values());
    const added = values.flatMap(v => v.added);
    const removed = values.flatMap(v => v.removed);
    const updated = values.flatMap(v => v.updated);
    const errors = values.flatMap(v => v.errors ?? []);
    const warnings = values.flatMap(v => v.warnings ?? []);
    const forceReload = values.some(v => v.forceReload);
    const data = `data: ${JSON.stringify({
        added,
        removed,
        updated,
        warnings,
        errors,
        forceReload,
    })}\n\n`;
    connectedClients.forEach(res => {
        if (res.socket?.destroyed) {
            connectedClients.delete(res);
        }
        try {
            res.write('event: change\n');
            res.write(data);
        }
        catch { }
    });
}
exports.notify = notify;
async function calculateHash(filePath) {
    return new Promise((resolve, reject) => {
        const hash = (0, crypto_1.createHash)('md5');
        const stream = (0, fs_1.createReadStream)(filePath);
        stream.on('data', d => hash.update(d));
        stream.on('end', () => {
            resolve(hash.digest('base64'));
        });
        stream.on('error', reject);
    });
}
//# sourceMappingURL=livereload-plugin.js.map